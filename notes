
- path
 - alternative
  - one func in expr
   - one stack of data value to cover all frags
   - mark start for each frag
   - descent add to stack
    - when rest is called it marks start and evals that frag
    - when done back up on frags
   - need to associate frag with item on the stack
    - can push frag onto stack
     - when popping back up check previous
     - if another frag then drop current and use new one
     - if value then frag should be applied to it after sliding the frag up to replace the value

 - test print
 - Expr funcs to build



- docs and unit tests for oj

- cmd/oj
  -colors list of colors or maybe map?
  -x extract expression (JSON Path)
   - also bare arg starting with @
  -m match against (if a match return whole json)

 -colors normal:blue:-:-:red:green

- examples

- path
 - oj.Path().Child("foo").Any().Child("bar")
 - oj.X().C("foo").A().C("bar")
 - build path with jp.Child("foo").Any().Child("bar")
  - each returns a jp.Expr , []jp.Frag and appends
 - oj.Expr{fp.Child("foo"), fp.Any{}}
 - oj.ParsePath("foo.*.bar")
 - eval
  - use calls on each frag
   - simpler except $ in filter
  - use stack
   - avoids function calls
  - Expr.Get() []interface{}
  - Expr.First() interface{}
  - Expr.GetNodes() []Node
  - Expr.FirstNode() Node
  - Expr.Set(data interface{}, value interface{}) error
   - if data is Node then convert the value to a Node, or error if can't convert
  - Expr.SetOne(interface{}, interface{}) error
  - Expr.Del()
  - Expr.DelOne()
  - Append([]byte) []byte

- ojg/doc.go
 - JSON tools
 - different approach than go json
  - interface{} the same, referred to as simple type
  - also generic data, not to be confused with golang discussions
   - types elements to match JSON, if it is allowed as an elemtn it will write to JSON
   - light weight with very low memory and performance impact
  - go json relies on decoration on fixed structs with no support for interface elements
   - borrowing from Oj for Ruby, types can be encoded and later recomposed
   - OjG supports multiple docs in one string or stream
  - includes builders for simple and generic
  - JSON path on generic and simple
  - validator


- jp - https://goessner.net/articles/JsonPath
 - jp.Str(n gd.Node, path string, defVal string) string
  - same on path expression or element or *fragment*
	// Get(key string) []Node
	// GetFirst(key string) Node
	// Set(path string, val Node) error
	// SetFirst(path string, val Node) error
	// Remove(key string) []Node
	// RemoveFirst(key string) Node
 - root - $
 - current - @
 - child - .foo
 - wildcard - .* or in array/subscript [*]
 - decendent (recursive) - ..
 - filter - [?()]
  - include || and &&, ==, !=, <=, >= <, >, (=~ for regex)
  - strings can be "" or ''
 - slice - [start:end:step]
 - union - [,]

Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)] matches items whose description starts with cat (case-insensitive).

Use to negate a filter: [?(!@.isbn)] matches items that do not have the isbn property.

- how to handle things in []
 - maybe [] is a check for an array/subscript
  - then things to do on the array elements after that
   - so ArrayStart expr followed by filter, slice, etc then terminated with an arrayEnd

- jp.Expr
 - has all top level funcs
 - []Frag
 - bracketed bool
 - Get
  - calls get() on first frag with array of rest
   - goes to next in array

- jp.Frag
 - get
 - first
 - set
 - setOne
 - remove
 - removeFirst

- parse methods
 - tried functions instead of switch, slower
  - tried array of 256 functions for value switching
 - all in one function is fastest
 - col++ created overhead as well
