
----------------

- cmd/oj
 - add -a and -asm option
  - allow sen format
  - if starts with [ then inline else a file

- asm package
 - should an alias be added to Fn?
 - functions
  + asm
  + inspect
  + quote
  + set
  + setall
  + get
  + del
  + delall
  + list
  + len or length or size

  + and
  + or
  + not
  + equal ==
  + neq !=
  + gt >
  - lt <
  - gte >=
  - lte <=

  - cond switch
  - each
   - @ points to {src:x}
   - let user define target as 2nd arg else default to @.asm

  - add
  - sub or minus
  - divide div
  - multiple times
  - mod

  - float
  - int
  - string - optional format specific to type being converted
  - time - option format if from string
  - zone - time to utc, local, offset

  - downcase
  - upcase
  - title
  - substr
  - trim
  - replace
  - join
  - split

  - include - string or list
  - append - strings or to a list
  - sort - list
  - reverse - list
  - nth - list or can jp handle that



- pretty json format
 - pretty package to form intermediate (pnode) tree
 - oj and sen to write
 - pretty.Tree(interface{})
  - build node tree
   - call alt.Decompose() first
   - or copy sen buildSen and build nodes in one pass
  - node
   - key string
   - val interface{} ([]pnode or simple)
    - use Val for []byte instead of a separate buf
   - asMap bool
   - size() int
    - a method on node calculates once Buf is set
 - open up oj.buildJSON and sen.buildSen
  - then can use pretty.JSON and pretty.Sen/SEN
  - maybe there is no need to open up
   - only string is different, with without quotes
    - maybe just open up buildString
    - or just copy
  - just need rules for comma
   - either ", " or " "


 - tighten up when possible
  - kind of like lisp
 - specify suggested max width
 - if max < depth * indent + size then indent 2 or 1
 - else indent of 0
 - if deeper than 3/8 or maybe 1/3 of max then use single space for indent
 - create first pass set of structs

 - run through json and create a new node for each slice and map
  - node points to slice or map and calculates length if indent of 0 and store size and depth




 - regex op =~
  - /^xyz&/
 - in addition to parse callback support chan for results
 - cmd/oj
  - read args from file (SEN format)
   - also check ~/.oj.fin or ~/.oj - graphql emacs mode works well
  - palette in cfg file
  - build or restructure json
   - use a template based approach along with JSONPath
- advanced ops
 - in - a in [1,2,3]
 - exists, empty, or has
 - size or length - [?(@.x size > 3)] or [?(size @.x > 3)]
-------------
- cmd/oj
  -colors list of colors or maybe map?
   -p (palette) key=red
   -key red

------------------

- Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)]
- Exists syntax? [?(@.x exists)]
