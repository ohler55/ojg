
----------------

- sen
 - get rid of extra space after } and ]
 - buildString => BuildString
  - make just a func
  - pass in []byte with &o.buf

- pretty json format
 - pretty package to form intermediate (pnode) tree
 - oj and sen to write
 - pretty.Tree(interface{})
  - build node tree
   - call alt.Decompose() first
   - or copy sen buildSen and build nodes in one pass
  - node
   - key string
   - val interface{} ([]pnode or simple)
    - use Val for []byte instead of a separate buf
   - asMap bool
   - size() int
    - a method on node calculates once Buf is set
 - open up oj.buildJSON and sen.buildSen
  - then can use pretty.JSON and pretty.Sen/SEN
  - maybe there is no need to open up
   - only string is different, with without quotes
    - maybe just open up buildString
    - or just copy
  - just need rules for comma
   - either ", " or " "


 - tighten up when possible
  - kind of like lisp
 - specify suggested max width
 - if max < depth * indent + size then indent 2 or 1
 - else indent of 0
 - if deeper than 3/8 or maybe 1/3 of max then use single space for indent
 - create first pass set of structs

 - run through json and create a new node for each slice and map
  - node points to slice or map and calculates length if indent of 0 and store size and depth




 - regex op =~
  - /^xyz&/
 - in addition to parse callback support chan for results
 - cmd/oj
  - read args from file (SEN format)
   - also check ~/.oj.fin or ~/.oj - graphql emacs mode works well
  - palette in cfg file
  - build or restructure json
   - use a template based approach along with JSONPath
- advanced ops
 - in - a in [1,2,3]
 - exists, empty, or has
 - size or length - [?(@.x size > 3)] or [?(size @.x > 3)]
-------------
- cmd/oj
  -colors list of colors or maybe map?
   -p (palette) key=red
   -key red

------------------

- Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)]
- Exists syntax? [?(@.x exists)]
