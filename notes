
- path-handler
 - PathDataHandler
  - collects data once there is a match then call func or method when path backs off to no match
   - dataDepth or collectDepth or StopLen (length of path when collection started and when it should stop)
   - Data being built
    - nil after callback
   - OnData func(path jp.Path, data any)

 - oj.ReaderFind(r io.Reader, target jp.Expr, cb func(path jp.Path, data any))
 - oj.Find(b []byte, target jp.Expr, cb func(path jp.Path, data any))
  - use Tokenizer with PathDataHandler
  - top level match, not top and leaves for $.. matches root only
 - same for sen


 - @.foo without a comparison indicates existance

- parse
 - add discover option to find JSON or SEN in a string or file
  - 3 states
   - DiscoverOff
   - DiscoverAny
   - DiscoverSets - only discover {} and []
  - starting map/mode is like value but no errors on invalid
   - same as value but replace errChar with a skip or skip and drop to drop current
    - if number then cb and drop
  - errors don't panic but close off current (if whole) and then back to discover maps
 - implement on all parsers

- embedded struct pointer encoding issue
- json.Unmarshaler
 - use alt.Recompose and convert simple to bytes and pass to unmarshaller

- pretty
 - align maps as well as arrays

- unit tests and example for cmd/oj

- optimize unmarshal
 - direct parse to struct

----------------

- option to detect duplicate keys or make part of validator
 - change stack to include array and map or maybe just map and nil means array
  - check performance hit
  - check added condition of whether keys should be checked. If too high then copy code
 - or separate stack in func for key maps along with dip code

-------------

- Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)]
- Exists syntax? [?(@.x exists)]
