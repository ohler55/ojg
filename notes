
----------------

- write
 - use stack
  - use key type
  - reverse items on stack if from list
  - if next on stack is array or map then no trailing comma
 - article
  - how to write optimized go code

- cmd/oj
 - -tab instead of indent
  - add Tab to option
   - if set then ignore indent and use tab instead

 - building output - build-out
  - seed
   - ^={a:123 b: @.bar}
  -  ^ for current build
   - ^.foo.bar=@.foo.baz
    - foo.bar=foo.baz as shortcut
  - % for globals
   - %.top+=^
  - = indicates Set(first, Get(second))
  - + indicates append is list otherwise nothing
 - display ^ at each input json
 - display % at end
 - ^.foo.bar=@.boo.hoo - first match (GetOne)
 - ^.foo.bar=[@.*.hoo] - array (Get)
 - ^.foo.bar+@.boo.hoo - add to array
 - ^.foo.del=
 - foo[2]=   - deletes array element 2
 - $top.array+=@.bar
 - $top.array+=@@

 - set option
  - |$.foo|| for delete
  - |$.foo|{"x":1}| for replace/set
  - |$.foo|@.bar| for set from within
  - eval in order
  - use any char as separator
  - also jp.Expr.Set(jp.Expr)
   - find with first path and replace with path arg relative to found

 - regex op =~
  - /^xyz&/
 - in addition to parse callback support chan for results
 - cmd/oj
  - read args from file (SEN format)
   - also check ~/.oj.fin or ~/.oj - graphql emacs mode works well
  - palette in cfg file
  - build or restructure json
   - use a template based approach along with JSONPath
- advanced ops
 - in - a in [1,2,3]
 - exists, empty, or has
 - size or length - [?(@.x size > 3)] or [?(size @.x > 3)]
-------------
- cmd/oj
  -colors list of colors or maybe map?
   -p (palette) key=red
   -key red

------------------

- Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)]
- Exists syntax? [?(@.x exists)]
