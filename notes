
- tasks before release
 - reflect for path
 - unit tests
 - docs
 - CI - travis or something else?
 - remove tree (maybe create separate benchmark repo)

- maybe a parser path wrapper that returns a Node
 - type assersions should always pass

- oj/jp
 - set reflection

- make gen.Key private

----------------
- next/todo
 - regex op =~
 - scripts
 - cmd/oj
  - palette
  - read args from file
  - build or restructure json
   - use a template based approach along with JSONPath

-------------
- cmd/oj
  -colors list of colors or maybe map?
   -p (palette) key=red
   -key red


- ojg/doc.go
 - JSON tools
 - different approach than go json
  - interface{} the same, referred to as simple type
  - also generic data, not to be confused with golang discussions
   - types elements to match JSON, if it is allowed as an elemtn it will write to JSON
   - light weight with very low memory and performance impact
  - go json relies on decoration on fixed structs with no support for interface elements
   - borrowing from Oj for Ruby, types can be encoded and later recomposed
   - OjG supports multiple docs in one string or stream
  - includes builders for simple and generic
  - JSON path on generic and simple
  - validator


- jp - https://goessner.net/articles/JsonPath
------------------

Match a JavaScript regular expression. For example, [?(@.description =~ /cat.*/i)] matches items whose description starts with cat (case-insensitive).

Use to negate a filter: [?(!@.isbn)] matches items that do not have the isbn property.

- how to handle things in []
 - maybe [] is a check for an array/subscript
  - then things to do on the array elements after that
   - so ArrayStart expr followed by filter, slice, etc then terminated with an arrayEnd


- parse methods attempted
 - tried functions instead of switch, slower
  - tried array of 256 functions for value switching
 - all in one function is fastest
 - col++ created overhead as well
